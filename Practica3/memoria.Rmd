---
title: 'Práctica 3: CTF'
subtitle: "Metodologías de desarrollo seguro - Ingeniería de la Ciberseguridad - 2023"
author: "Carlos Barahona Pastor y Ángel del Castillo González"
output: pdf_document
---
\begin{center}
    \includegraphics{urjc.png}
\end{center}


\newpage
```{=tex}
\subpdfbookmark{Índice}{indice}
\renewcommand{\contentsname}{Índice}
\tableofcontents
```

\newpage

# Whack-a-mole

## Descripción
Se trata del juego de whack-a-mole. El cuál consiste en un cuadrado de madrigueras de los cuales van saliendo topos ("moles") y hay que "machacarlos" para obtener puntos.


## Explicación

El código empleado para la resolución es el siguiente:

```{python, eval=FALSE, results=FALSE}
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC


def whack_a_mole(driver):
    driver.get("http://localhost")

    puntos = WebDriverWait(driver, 15).until(EC.presence_of_element_located((By.ID, "score")))
    while int(puntos.text) < 10001:
        try:
            topo = driver.find_element(By.CLASS_NAME, "mole")
            topo.click()
        except:
            pass

    flag = driver.find_element(By.ID, "flag")
    flag = flag.text

    print(str(flag))



if __name__ == '__main__':
    driver = webdriver.Chrome()
    whack_a_mole(driver)
    driver.quit()
    
```


### Main

El código "Main" es el siguiente:

```{python, eval=FALSE, results=FALSE}
if __name__ == '__main__':
    driver = webdriver.Chrome()
    whack_a_mole(driver)
    driver.quit()
```

- Primeramente creamos una variable driver que contiene un `webdriver` para Chrome con el que manejaremos el navegador.
- LLamamos a la función "whack_a_mole" a la que le pasamos el driver para poder completar el juego.
- Por el último llamamos a "quit" para acabar con la sesión del webdriver.


### Whack-a-mole

Primeramente hemos levantado el reto en un servidor HTTP en local

```{python, eval=FALSE, results=FALSE}


def whack_a_mole(driver):
    driver.get("http://localhost")

    puntos = WebDriverWait(driver, 15).until(EC.presence_of_element_located((By.ID, "score")))
    while int(puntos.text) < 10001:
        try:
            topo = driver.find_element(By.CLASS_NAME, "mole")
            topo.click()
        except:
            pass

    flag = driver.find_element(By.ID, "flag")
    flag = flag.text

    print(str(flag))
    
```

- Comenzamos cargando la página que tenemos levantada en local.
- Esperamos hasta que encontremos un elemento cuyo `ID` sea `score`, lo almacenamos en la variable, puntos ya que contiene los puntos que vamos consiguiendo.
- Entramos al bucle while que se ejecuta hasta que lleguemos a 10000 puntos, los necesarios para obtener la flag, para obtener la puntuación accedemos a su atributo `text`, y como es un String, hacemos un cast para pasarlo a int.
- A continuación, entramos en un `try` que busca las etiquetas que contengas el nombre de clase `mole` y haga click sobre ellas para sumar puntos.
- El `try, except` se debe que a veces en el bucle while busca las etiquetas de nombre de clase ``mole` y justo en ese momento no hay ninguna, por lo tanto se produce una excepción que la dejamos pasar.
- Una vez llegado a los 10000 puntos aparece una etiqueta cuyo ID es `flag`, la buscamos, accedemos a su atributo `text` y la mostramos.

## Flag

URJC{S3l3n1Um_M0l3_m0l3}

## Arreglos y mejoras

??????????????????????????????????????????????



\newpage

# Blog

## Descripción

En este reto se pide encontrar el número de apariciones de la cadena `URJC` en todas las páginas. En este caso la funcionalidad que se ha automatizado ha sido la de visitar los enlaces y la de contar el número de veces que aparece la cadena en cada página.

## Explicación

El código que se ha utilizado es el siguiente:

```{python, eval=FALSE, results=FALSE}
from selenium import webdriver
from collections import deque
import re
from selenium.webdriver.common.by import By


def links_bfs():
    q = deque()
    visited = set()
    total_count = 0
    start = "https://r2-ctf-vulnerable.numa.host/"
    regex = r'\bURJC\b'
    visited.add(start)
    q.append(start)
    while q:
        name = q.popleft()
        driver.get(name)
        count = len(re.findall(regex, driver.page_source))
        total_count += count
        links = driver.find_elements(By.XPATH, "//h2[contains(@class,'card-title')]/a")
        for next_link in links:
            next_name = next_link.get_attribute("href")
            if next_name not in visited:
                visited.add(next_name)
                q.append(next_name)
    print(total_count)


if __name__ == '__main__':

    driver = webdriver.Chrome()
    driver.maximize_window()
    links_bfs()
    driver.quit()

```

Tras los correspondientes `imports` el código contiene 2 partes mayoritariamente, las cuales se explicarán a continuación.

### main

El código `main` es el siguiente:

```{python, eval=FALSE, results=FALSE}
if __name__ == '__main__':

    driver = webdriver.Chrome()
    driver.maximize_window()
    links_bfs()
    driver.quit()
```

Consta de los siguientes elementos:

- Una variable `driver` que inicializa el webdriver de chrome (`webdriver.Chrome()`) el cual se encargará de manejar el navegador automáticamente.
- La llamada a la función `driver.maximize_window()` usada para maximizar la ventana del navegador.
- La llamada a la función `links_bfs()` que es la encargada de ir recorriendo los distintos links y contando las apariciones.
- La llamada a la función `driver.quit()` la cual se encarga de cerrar el navegador y terminar la sesión del `webdriver`.

### links_bfs()

Una vez explicada la función `main`, se va a explicar la función `links_bfs()`. Esta función utiliza el algoritmo BFS (**B**readth **F**irst **S**earch) para ir visitando los distintos enlaces. Es un algoritmo de búsqueda usado para visitar los nodos de un grafo y adaptado en este caso para visitar los enlaces y contar las apariciones de la cadena pedida. La primera parte de la función que se corresponde con las variables iniciales es la siguiente:

```{python, eval=FALSE, results=FALSE}
def links_bfs():
    q = deque()
    visited = set()
    total_count = 0
    start = "https://r2-ctf-vulnerable.numa.host/"
    regex = r'\bURJC\b'
    visited.add(start)
    q.append(start)
```

Esta parte consta de los siguientes elementos:

- Lo primero que se hace es almacenar en la variable `q` una cola doblemente terminada (`deque()`) para añadir elementos por un lado y extraerlos por el otro.
- Lo siguiente es un conjunto vacío (`set()`) almacenado en `visited` que irá almacenando los nodos que ya han sido añadidos a la cola y que por tanto ya habrán sido visitados (o serán visitados porque estén en la cola) para evitar repeticiones.
- Tras eso se inicializa a 0 la variable `total_count` que almacenará las apariciones de `URJC`.
- Ahora se almacena en la variable `start` la dirección desde la que se empezará la búsqueda, que es la página principal del reto (`https://r2-ctf-vulnerable.numa.host/`).
- A continuación se crea una variable `regex` cuyo contenido es `r'\bURJC\b'` que en este caso buscará exactamente la cadena `URJC` que tenga al principio y al final un delimitador `\b`
- Por último se añade a `visited` la dirección de inicio mediante `visited.add(start)` y se añade a la cola mediante `q.append(start)` para después extraerlo y comprobar el contenido de ese enlace.

La siguiente parte es el bucle `while` que se irá encargando de recorrer los nodos y su código es el siguiente:

```{python, eval=FALSE, results=FALSE}
while q:
        name = q.popleft()
        driver.get(name)
        count = len(re.findall(regex, driver.page_source))
        total_count += count
        links = driver.find_elements(By.XPATH, "//h2[contains(@class,'card-title')]/a")
        for next_link in links:
            next_name = next_link.get_attribute("href")
            if next_name not in visited:
                visited.add(next_name)
                q.append(next_name)
    print(total_count)
```

El bucle se ejecuta mientras haya elementos restantes en la cola y se compone de lo siguiente:

- Lo primero es sacar el primer elemento de la izquierda de la cola (mediante `q.popleft()`) y se le asigna a la variable `name`. Este nombre se corresponde con el enlace que se va a analizar en esta iteración.
- Una vez se tiene el nombre del enlace, se visita esa página usando la función `driver.get(name)`.
- Tras eso, se almacena en la variable `count` el número de apariciones de `URJC` las cuales se calculan de la siguiente forma:
    - Mediante la función `re.findall(regex, driver.page_source)` se obtiene una lista con las coincidencias en base a `regex` (que contenía la expresión regular para encontrar coincidencias de la cadena `URJC`) halladas en el código fuente de la página (el cual se obtiene con `driver.page_source`)
    - Tras usar `re.findall()`, se usa la función `len()` para determinar cuantos elementos tiene la lista que será el número de veces que se haya encontrado la cadena.
- Una vez se tiene el número de apariciones se le suma a la variable `total_count` mediante `total_count += count` para ir almacenando el número total.
- Después se crea una variable `links` que buscará los enlaces que contenga esa página usando para ello la función `driver.find_elements()`. Esta función contiene 2 parámetros:
    - Por un lado `By.XPATH` que indica que se buscarán los enlaces usando `XML Path` para poder navegar entre las etiquetas `HTML`.
    - Por otro lado se indica mediante `"//h2[contains(@class,'card-title')]/a"` que se quieren obtener las etiquetas que tengan el formato `<h2 class='card-title'><a href>`. Estas etiquetas son las que contienen los enlaces.
- Una vez obtenidas las etiquetas, se itera en cada resultado `next_link` usando un bucle `for` que hace lo siguiente:
    - Lo primero que realiza es almacenar en la variable `next_name` el resultado de la función `next_link.get_attribute("href")` que lo que hace es extraer de la etiqueta previamente obtenida el contenido de `href`, el cual se corresponde con la `URL` de la página correspondiente.
    - Una vez obtenida la `URL` se comprueba que no esté visitada ya mediante `if next_name not in visited:` para evitar repeticiones.
    - Si no está visitada, se añade a `visited` mediante `visited.add(next_name)` y se añade a `q` para encolarla usando `q.append(next_name)` y más tarde procesarla.
- Una vez ha terminado el `while` se imprime el número total de apariciones mediante `print(total_count)`

## Flag

La flag de este reto es `URJC{N}` siendo N el número de apariciones, por lo que en este caso la flag quedaría: **URJC{265}**

## Arreglos y mejoras

Para impedir la automatización, se podría intentar usar algún método que compare el tiempo entre solicitudes desde una misma fuente, y si está por debajo de cierto umbral, bloquear la conexión para no poder seguir navegando por las distintas páginas del servidor.

# Calculadora

## Descripción



## Detección



## Explicación



## Flag



## Arreglos y mejoras

\newpage


# 10 Fast Fingers

## Descripción

El reto consta de un texto a escribir en 5 segundos para obtener la flag, realizarlo a mano es un poco "imposible", por eso hemos escrito un código en Python.


## Detección



## Explicación

El código utilizado para la resolución es el siguiente:

```{python, eval=FALSE, results=FALSE}
from selenium import webdriver
from selenium.webdriver.common.by import By
import time



def fastfingers(driver):
    driver.get("http://localhost")
    time.sleep(5)
    #Hay un contenedor que contiene to el texto a teclear
    palabras = driver.find_element(By.ID, "textDisplay").text
    clickear = driver.find_element(By.CLASS_NAME, "text-input")

    clickear.send_keys(palabras)
    clickear.send_keys(" ")
    time.sleep(10) #10 segundos pa ver la flag 




if __name__ == '__main__':

    driver = webdriver.Chrome()
    fastfingers(driver)
    driver.quit()
    
    
```


### Main
```{python, eval=FALSE, results=FALSE}
if __name__ == '__main__':
    driver = webdriver.Chrome()
    fastfingers(driver)
    driver.quit()
```

- Primeramente creamos una variable driver que contiene un `webdriver` para Chrome con el que manejaremos el navegador.
- LLamamos a la función "fastfingers" a la que le pasamos el driver para poder completar el juego.
- Por el último llamamos a "quit" para acabar con la sesión del webdriver.


### Fastfingers

Primeramente hemos levantado el reto en un servidor HTTP en local

```{python, eval=FALSE, results=FALSE}
def fastfingers(driver):
    driver.get("http://localhost")
    time.sleep(5)
    #Hay un contenedor que contiene to el texto a teclear
    palabras = driver.find_element(By.ID, "textDisplay").text
    clickear = driver.find_element(By.CLASS_NAME, "text-input")

    clickear.send_keys(palabras)
    clickear.send_keys(" ")
    time.sleep(10) #10 segundos pa ver la flag 


```

- Primero cargamos la página principal del reto que tenemos levantado en el local.
- Ponemos a dormir 5 segundos el programa para que cargue todo correctamente.
- A continuación, buscamos el texto a introducir en la etiqueta cuyo `ID` es `textDisplay` accedemos al atributo `text` y lo almacenamos en la variable "palabras".
- En la variable clickear buscamos la etiqueta cuyo `class name` sea `text-input`, es por donde vamos a introducir las palabras del reto.
- Con la función `send_keys(palabras)`, enviamos las palabras como si estuviéramos escribiendo por teclado.


## Flag

URJC{m3ch4nic_k3yb04rd?}


## Arreglos y mejoras

???????????????????????????????????????


# La lotería

## Descripción

En este reto se pide adivinar el siguiente número que va a salir en una página que genera números aleatoriamente,

## Detección

En este caso, la vulnerabilidad que se ha detectado es el uso de la función `Random.nextInt()`. Esta función es vulnerable ya que si se conoce la semilla a partir de la cual se están generando los números, se podrán calcular de la misma forma que lo hace el código de la página. En este caso la página usa como semilla el resultado de la función `System.currentTimeMillis()` (que es la diferencia en milisegundos entre el momento que se llama a la función y la medianoche del 1 de enero de 1970), y al utilizar eso como semilla se podría averiguar el valor exacto de la función ejecutando la misma en la máquina local y restando un milisegundo hasta que los números generados cuadrasen.

## Explicación

```{java, eval=FALSE, results=FALSE}
package com.lottery.lottery;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import java.util.Random;


public class Lottery {
    private static final int MAX_NUMBER = 1_234_000_100;
    public static void main(String[] args){
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--remote-allow-origins=*");
        WebDriver driver = new ChromeDriver(options);
        int next_number = -1;
        boolean correct_token = false;

        driver.get("https://r1-ctf-vulnerable.numa.host/");
        driver.findElement(By.xpath("//button[text()='Start from scratch']")).click();
        long end = System.currentTimeMillis();
        driver.findElement(By.className("form-control")).sendKeys("1");
        driver.findElement(By.xpath("//button[text()='Check']")).click();

        String number_s = driver.findElement(By.xpath("//ul/il")).getText();
        int number = Integer.parseInt(number_s);

        while (0 < end && !correct_token){
            Random random = new Random(end);
            int current_number = random.nextInt(MAX_NUMBER);
            if (current_number == number){
                correct_token = true;
                next_number = random.nextInt(MAX_NUMBER);
            }
            end--;
        }

        driver.get("https://r1-ctf-vulnerable.numa.host/");
        if (correct_token){
            driver.findElement(By.className("form-control")).
                    sendKeys(Integer.toString(next_number));
            driver.findElement(By.xpath("//button[text()='Check']")).click();
            String flag = driver.findElement(By.tagName("p")).getText();
            System.out.println(flag);
        }
        else{
            System.out.println("FLAG not found");
        }
        driver.quit();
    }
}



```

Lo primero que se hace es realizar los correspondientes `imports`. Una vez realizados, se crea la clase `Lottery`, la cual contiene una variable privada, final, y estática llamada `MAX_NUMBER` que marca el rango en el que se generan números aleatorios. A continuación se tiene la función `main` que consta de varias partes que se describirán a continuación.

### Variables iniciales

```{java, eval=FALSE, results=FALSE}
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--remote-allow-origins=*");
        WebDriver driver = new ChromeDriver(options);
        int next_number = -1;
        boolean correct_token = false;
```

Las variables iniciales son las siguientes:

- Una variable `options` de tipo `ChromeOptions` para añadir como argumento \textbf{options.addArguments("--remote-allow-origins=*");} (esto es necesario debido a que si no se habilitan los orígenes remotos, no se puede establecer la conexión con la página del reto ya que aparecerá un mensaje `403 Forbidden`).
- Una variable `driver` de tipo `WebDriver` con las opciones establecidas previamente para poder manejar el navegador automáticamente de la siguiente forma `WebDriver driver = new ChromeDriver(options);`.
- Una variable `next_number` puesta a `-1` que será la que almacene el siguiente número a introducir en la página.
- Una variable `correct_token` puesta a `false` que será la que marque si se ha encontrado el `token` correcto con el que generar los números.

### Prueba para obtener el primer número

```{java, eval=FALSE, results=FALSE}
        driver.get("https://r1-ctf-vulnerable.numa.host/");
        driver.findElement(By.xpath("//button[text()='Start from scratch']")).click();
        long end = System.currentTimeMillis();
        driver.findElement(By.className("form-control")).sendKeys("1");
        driver.findElement(By.xpath("//button[text()='Check']")).click();

        String number_s = driver.findElement(By.xpath("//ul/il")).getText();
        int number = Integer.parseInt(number_s);
```

Lo primero que se hace es entrar a la página principal usando \textbf{driver.get("https://r1-ctf-vulnerable.numa.host/");}. Nada más entrar a la página aparece un recuadro donde escribir el número que se desea comprobar, un botón de `check` y un botón que dice `Start from scratch`. Este último botón lo que hace es reiniciar el generador de números aleatorios usando como semilla la función `System.currentTimeMillis()` como ya se ha comentado previamente, por lo que se hará click en ese botón mediante \textbf{driver.findElement(By.xpath("//button[text()='Start from scratch']")).click();}. 

Justo después de hacer `click` se crea una variable `end` a la que se le asignan los milisegundos actuales haciendo `long end = System.currentTimeMillis();`

\begin{quote}
\textit {Cuando se hace click en el botón, la máquina de la página obtiene la hora en milisegundos, sin embargo no se puede saber el milisegundo exacto que ha devuelto la función. Es necesario por tanto llamar a esa función desde el código (que devolverá una cantidad en milisegundos mayor) para así más tarde en un \texttt{while} irle restando 1 milisegundo en cada iteración hasta dar con el milisegundo que coincida.}
\end{quote}

Tras eso lo que se hace es escribir un número cualquiera (1 en este caso) en el campo de `input` de la página, lo cual se puede hacer usando `driver.findElement(By.className("form-control")).sendKeys("1");`. Una vez rellenado el formulario, se hace click en el botón `check` para mandarlo mediante `driver.findElement(B`  
`y.xpath("//button[text()='Check']")).click();`.

La página que se devuelve contiene el número correcto que se tendría que haber adivinado, por lo que se obtiene ese número mediante `String number_s = driver.findElement(By.xpath("//ul/il")).getText();` y se transforma a entero haciendo `int number = Integer.parseInt(number_s);`.

### Bucle while

```{java, eval=FALSE, results=FALSE}
        while (0 < end && !correct_token){
            Random random = new Random(end);
            int current_number = random.nextInt(MAX_NUMBER);
            if (current_number == number){
                correct_token = true;
                next_number = random.nextInt(MAX_NUMBER);
            }
            end--;
        }
```

Una vez se tiene el número, se ejecuta un `while` mientras que `end` sea mayor que 0 (`end` no debería de ser mayor que los milisegundos obtenidos en la máquina de la página pero se pone ese límite por si hubiera algún problema para que no itere de forma infinita) y mientras que `!correct_token`, es decir, mientras que no se haya encontrado el `token` correcto. Una vez explicado eso, el cuerpo del `while` consta de los siguientes elementos:

- Lo primero que se hace es crear una variable `random` (`Random random = new Random(end);`) usando como semilla los milisegundos obtenidos anteriormente (`end`) para generar un número y ver si coincide con el que ha devuelto la página.
- Tras crear el generador, se crea una variable `current_number` a la que se le asigna el resultado de la función `random.nextInt(MAX_NUMBER)`. Esta función devuelve siempre el mismo número aleatorio entre 0 y `MAX_NUMBER` usando una semilla determinada (por eso la función es insegura si se conoce la semilla).
- Una vez se obtiene el número, se compara con el que devolvió la página, y si son iguales significará que la semilla que se está probando ahora es la misma que la que usó la máquina de la página para crear el generador por lo que se pone `current_token = true` para indicar que se ha encontrado la semilla y se guarda en `next_number` el resultado de `random.nextInt(MAX_NUMBER)` (que será el siguiente número que está esperando la página).
- Por último se le resta 1 a `end` haciendo `end--;` para que el bucle se siga ejecutando en caso de que todavía no se hubiese encontrado la semilla correcta.

### Comprobación de resultados y obtención de la flag

```{java, eval=FALSE, results=FALSE}
        driver.get("https://r1-ctf-vulnerable.numa.host/");
        if (correct_token){
            driver.findElement(By.className("form-control")).
                    sendKeys(Integer.toString(next_number));
            driver.findElement(By.xpath("//button[text()='Check']")).click();
            String flag = driver.findElement(By.tagName("p")).getText();
            System.out.println(flag);
        }
        else{
            System.out.println("FLAG not found");
        }
        driver.quit();
```

Tras el `while`, lo primero que se hace es volver a la página principal haciendo \textbf{driver.get("https://r1-ctf-vulnerable.numa.host/");} y una vez en la página principal se comprueba mediante un `if` el valor de `current_token`. Si `current_token` es `true` significará que se ha encontrado la semilla correcta, por lo que se introduce el número (transformado a texto) obtenido en el `while` anterior (que será el siguiente número correcto que esperará la página) mediante `driver.findElement(By.className("form-control")).sendKeys(Integ`  
`er.toString(next_number));`. Tras eso se hace click en el botón de `check` y se obtiene la `flag` extrayéndola de la página devuelta mediante `String flag = driver.findElement(By.tagName("p")).getText();`. Una vez obtenida se imprime mediante `System.out.println(flag);`. En caso de que no se hubiera encontrado la semilla se imprime por pantalla que no se ha encontrado la flag mediante `System.out.println("FLAG not found");`. Por último se usa `driver.quit();` para cerrar el navegador de `Chrome`.
 
## Flag

La flag en este caso es: **URJC{Ahora_prueba_con_los_numeros_de_la_loteria_:D}**

## Arreglos y mejoras

Para arreglar la vulnerabilidad, habría que utilizar un generador de números aleatorios seguros como la clase `SecureRandom` de `Java`cuya generación garantiza que los números sean criptográficamente seguros.


\newpage



# Agenda

## Descripción

El programa consiste en una agenda de contactos dónde puedes añadir/crear un contacto o pedir que te lo muestre.

## Detección

En la función `show_contact()` podemos buscar un número en la agenda pero solamente se comprueba si el número que leemos es mayor que el tamaño máximo

```{c, eval=FALSE, results=FALSE}

void show_contact(){
    printf("Que contacto quieres recuperar? Indica su posicion en la agenda.\n");
    int pos;
    scanf("%d", &pos);

    if(pos >= SIZE){
        printf("Posicion invalida! Que tramas?\n");
        return;
    }

    printf("El numero de la posicion %d es %s\n", pos, agenda[pos]);
}

```

Pero, ¿qué pasa si metemos números negativos?

## Explicación

Si metemos valores negativos, podremos acceder a zonas de memoria, las cuales no deberíamos acceder.
\begin{center}
    \includegraphics{intentos.jpg}
\end{center}


\begin{center}
    \includegraphics{intento_y_flag.jpg}
\end{center}


## Flag

URJC{Why_so_negative}

## Arreglos y mejoras

Deberíamos añadir la comprobación de que el número leído para buscar sea mayor o igual que 0, para que no se accedan a otras direcciones de memoria.

```{c, results=FALSE, eval=FALSE}
void show_contact(){
    printf("Que contacto quieres recuperar? Indica su posicion en la agenda.\n");
    int pos;
    scanf("%d", &pos);

    if(pos >= SIZE || pos < 0){
        printf("Posicion invalida! Que tramas?\n");
        return;
    }

    printf("El numero de la posicion %d es %s\n", pos, agenda[pos]);
}

```

Si se cumplen una de las dos condiciones, no devuelve ningún contacto.


\newpage




# Agenda v2

## Descripción
El programa consiste en una agenda de contactos dónde puedes añadir/crear un contacto o pedir que te lo muestre.

## Detección

Según la [documentación de python](https://docs.python.org/2/library/functions.html#input), la función input realiza por debajo lo siguiente: `eval(raw_input(prompt))`.

\begin{center}
    \includegraphics{doc.jpg}
\end{center}

El método `eval()` puede ser usado para ejecutar código arbitrario, por lo tanto `input()` en Python2 es vulnerable.
Por ejemplo, la siguiente parte del código podemos intentar ejecutar código.

```{python, eval=FALSE, results=FALSE}
import os

def add_contact():
    print("En que posicion de la agenda quieres almacenar el numero?\n")
    pos = int(input())

    if pos >= SIZE or pos < 0:
        print("Posicion invalida! Quieres hacer un overflow?\n")
        return


    print("Introduce el numero: ")
    agenda[pos] = input()


```


Además, el código importa la librería `os` con la que podemos acceder a variables de entorno como `CHALLENGE_FLAG` que es donde se guarda la flag del reto.


```{docker, eval=FALSE, results=FALSE}
environment:
      - CHALLENGE_FLAG=URJC{change_me}

```


## Explicación

Como hemos dicho antes la función input es vulnerable, entonces si introducimos la siguiente línea en cualquier parte que ejecute input: `os.getenv('CHALLENGE_FLAG')` para obtener el contenido de la variable de entorno de la flag. 

\begin{center}
    \includegraphics{cuela.jpg}
\end{center}


\begin{center}
    \includegraphics{flag_python.jpg}
\end{center}


## Flag

URJC{Python2_is_old}

## Arreglos y mejoras

Usar raw_input() como método para leer inputs en Python2 ya que todo lo recibe lo convierte en strings. Otra opción es dejar de usar Python2 y empezar a usar Python3 cuya función input no es vulnerable.





