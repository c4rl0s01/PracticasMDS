---
title: "Práctica Análisis Estático"
author: "Carlos Barahona Pastor y Ángel del Castillo González, Grupo Q"
subtitle: "Metodologías de Desarrollo Seguro, Ingeniería de la Ciberseguridad"
output:
  pdf_document
---


```{=tex}
\subpdfbookmark{Índice}{indice}
\renewcommand{\contentsname}{Índice}
\tableofcontents
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage
#Enlaces Repositorios

https://github.com/c4rl0s01/PracticasMDS
https://github.com/c4rl0s01/WebGoat


# Expresiones regulares

## Ejercicio 1. 

### Enunciado

Dado un texto de una sola línea, determinar todos los años (números formados estrictamente por 4 dígitos) que aparecen. Un año es una cadena numérica de longitud 4, con cualquier valor en el rango [0000, 9999]. Se tendrán que imprimir por pantalla en el lenguaje deseado usando una expresión regular todos los años que vienen en el texto en orden de aparición, en una línea cada uno.

### Resolución




## Ejercicio 2. 

### Enunciado

Dado un texto de una línea, determinar todas las matrículas que aparecen. Una matrícula es una cadena que tiene las siguientes características:

  - 4 dígitos seguidos de un separador (guion, espacio o nada) y 3 letras en mayúsculas al final tal que [0000 - AAA, ..., 9999 - ZZZ].
  - Las matrículas pueden llevar una E mayúscula delante para indicar que se trata de un vehículo
especial. Ejemplos: E1337ZZZ, E-0000 PCB.
  - Los dígitos pueden estar separadas de las letras utilizando un guion, un espacio, o ningún separador.
Se tendrán que imprimir por pantalla usando el lenguaje elegido usando una expresión regular todas las matrículas que vienen en el texto en orden de aparición

### Resolución

Para la resolución del ejercicio, hemos escrito el siguiente código:

```{python, eval=FALSE}
import re

new = input()
pattern = r'(\bE[-|\s|\S]?[0-9]{4}[|\s|\-]?[A-Z]{3})|([0-9]{4}[-|\s|\S]?[A-Z]{3}\b)'

x = re.findall(pattern, new)


for match in x:
    if match[1] != '':
        print(match[1])
    elif match[0] != '':
        print(match[0])


```

En la anterior expresión regular se diferencian dos grupos, en el primero tendremos que buscar matrículas que comiencen con E y estén seguidas de un guión, espacio o ningún espacio, "[-|\\s|\\S]", a continuación tendrá 4 números "[0-9]\{4\}" seguidos de un espacio, guión o ningún espacio, después de esto deberá tener tres letras mayúsculas "[A-Z]\{3\}". En el último grupo tendremos solamente 4 números "[0-9]\{4\}" seguidos de espacio, guión o ningún espacio, finalizando con tres letras mayúsculas "[A-Z]\{4\}"

## Ejercicio 3. 

### Enunciado

Dado un formato de fechas yyyy-mm-dd, se pide convertir a dd.mm.yyyy. Para cada match encontrado en los documentos propuestos se tendrá que imprimir en el siguiente formato (los rangos de fecha puede ser erróneos, pueden existir un mes 20).

### Resolución
  
  
  
## Ejercicio 4.

### Enunciado

Dado un texto, determinar cuando se ha encontrado un email de alumno de nuestra universidad “@alumnos.urjc.es” o profesor “@urjc.es”. Los emails de alumnos están formados del siguiente patrón (puedes asumir que el input siempre estará en minúscula): 

  - Inicial del usuario, seguido de punto.
  - Apellido del usuario, siempre mayor o igual a 2 caracteres.
  - Seguidos de un punto y la fecha de matriculación. ´
  - todos finalizan con “@alumnos.urjc.es”.


Los correos de los profesores constan de:

  - Nombre del profesor seguido de un punto.
  - Apellido del profesor.
  - Finalizando con “@urjc.es”.

Para cada match encontrado se tendrá que imprimir en el siguiente formato:

  - Para el caso de prueba i.lozanoo.2015@alumnos.urjc.es reportaremos “alumno lozanoo matriculado en 2015”
  - Para un profesor reportaremos para el ejemplo isaac.lozano@urjc.es “profesor isaac apellido lozano”
  
### Resolución

Para la resolución del ejercicio, hemos escrito el siguiente código:

```{python, eval=FALSE}
import re

new = input()

pattern = r"\b(([a-z]{1,})\.([a-z]{2,})@urjc\.es)|\b(([a-z]{1}) \
            \.([a-z]{2,})\.([0-9]{4})@alumnos\.urjc\.es)"

results = re.findall(pattern, new)


for match in results:
    if match[0] != "":
        print("profesor "+match[1]+" apellido "+match[2])
    else:
        print("alumno "+match[5]+" matriculado en "+match[6])

```

En este ejercicio tenemos dos grupos principales, el correo de profesor y el correo de alumno. En el grupo del profesor, creamos dos grupos internos que son el nombre el cual está compuesto por letras minúsculas "[a-z]\{1,\}" seguido de un punto, y el siguiente grupo que es el apellido compuesto por letras minúsculas "[a-z]\{1,\}" finalizando con @urjc.es. El segundo grupo principal es el correo de alumnos que también está formado por otros grupos internos, en este caso tres, y son: la letra del nombre "[a-z]\{1\}", seguido de un punto, el apellido "[a-z]\{1,\}" seguido de un punto, y el año de matriculación,"[0-9]\{4\}", finalizando con @alumnos.urjc.es. Para mostrar la salida según el formato pedido, accedemos al grupo con el que hacemos el match.

## Ejercicio 5.

### Enunciado

Dado un texto devolver las direcciones postales. Una dirección estará compuesta de una calle representada por “C/” o ”Calle” seguido de un espacio con el nombre de la calle (una sola palabra) donde la primera letra debe estar en mayúscula, opcionalmente una coma, un numero arbitrario de espacios, el número en cualquiera de los siguientes formatos (Nº7, nº7, N 7, n 7, 7, Nº 7, nº 7, n7, N7). No es valido Nº7, n º7, ni º7, la N podría estar en mayúsculas o minúsculas. Seguido, una coma, un número arbitrario de espacios y un numero de 5 dígitos correspondiente a un código postal. Los nombres de las calles deben poder validar calles de Madrid formadas por una sola palabra, no es necesario que reconozca “Calle Almendro Azul”, porque el nombre de la calle tiene dos palabras en vez de una.
Ejemplos de casos:

  - “C/ Dulcinea Nº 10, 28936”
  - “Calle Dulcinea 10, 28106”
  - “Calle Dulcinea N10, 28091”
Para cada calle encontrada se reportara: “CP-Calle-Numero”, por ejemplo: “28926-Dulcinea-10”.

### Resolución
	
## Ejercicio 6. 

### Enunciado

Dado un fichero de logs, transformar cada línea a CSV extrayendo la siguiente información:

	- Nivel de log
	- Hilo donde se ha producido el log (este hilo se corresponde
	  con letras en mayúscula, minúscula y de números) 
	- Clase responsable de emitir el log
	- Mensaje de log

### Resolución

Para la resolución del ejercicio, hemos escrito el siguiente código:
```{python, eval=FALSE}
import re

new = input()

pattern = r"([A-Za-z]{1,}).{1,}\[([a-zA-Z0-9]{1,})\]\s+(.{1,}\S)\s+\:\s+(.{1,})"

results = re.search(pattern, new)

if results:
    level_log = results.group(1)
    thread_log = results.group(2)
    class_log = results.group(3)
    message_log = results.group(4)

    if class_log.__contains__("."):
        class_split = class_log.split(".")
        l = len(class_split) - 1
        class_log = class_split[l]


    print(f'"{level_log}","{thread_log}","{class_log}","{message_log}"')

```

En este ejercicio diferenciamos cuatro grupos: nivel, hilo, clase, mensaje. El nivel lo encontramos con las primeras letras que haya en el log y puede contener mayúsculas o minúsculas las veces que sea "[A-Za-z]\{1,\}", con ".\{1,\}" seleccionaremos todo lo contenido en el log hasta encontrar el segundo grupo. El hilo se encuentra entre corchetes y puede contener mayúsculas, minúsculas o números, "[a-zA-Z0-9]\{1,\}", seguido de un número de espacios encontraremos el tercer grupo. La clase cogemos todos los caracteres que haya hasta el siguiente caracter que no  sea un espacio,"(.\{1,\}\\S)", seguido de un número de espacios hasta ":" y unos espacios después encontramos el último grupo. Para el mensaje que se encuentra después de los ":" y espacios, el mensaje será todos los carácteres siguientes hasta terminar el log ".\{1,\}". 
Para tener el output pedido hemos hecho un tratamiento de la clase, ya que puede contener caracteres y puntos, y solo nos interesa los últimos caracteres, por lo tanto, si contiene puntos, dividimos cada el resultado por cada punto y nos quedamos con el último miembro del array obtenido.

# Integración Continua

## Preguntas Puesta en marcha del proceso análisis automático

### 1. ¿Cuantas vulnerabilidades, bugs y code smells ha detectado SonarCloud en el proyecto entero?

Estos son los datos que ha arrojado SonarCloud:

- Vulnerabilidades: 30
- Bugs: 32
- Code smells: 565

### 2. Haz click sobre el proyecto para abrir la vista de detalle. Revisa las vulnerabilidades detectadas y la lista de Security Hotspots. ¿Qué diferencia crees que existe entre las vulnerabilidades y los Security Hotspots?

La diferencia es que las **vulnerabilidades** hacen referencia a código que se ha detectado que puede ser explotado, mientras que los **Security Hotspots** son fragmentos de código que deben ser revisados, ya que aunque no se haya podido determinar a priori si son una vulnerabilidad o no en el escaneo, podrían serlo por lo que deben analizarse de forma manual para determinarlo.

### 3. Haz cualquier commit para forzar un reanalisis (por ejemplo editando el README.md). Espera a que finalice y vuelve a Sonar. ¿Cual es el estado del proyecto (Passed/Failed)?. ¿A qué crees que se debe? ¿Crees que el numero de vulnerabilidades afecta a dicho veredicto?

Tras editar el archivo README.md, el estado del proyecto es `Failed`. Esto se debe a que para que el estado de un proyecto sea `Passed`, se tienen que cumplir una serie de condiciones de la `Quality Gate`. En este caso específico, las condiciones que no se cumplen son:

- `Reliability Rating`: este apartado hace referencia al número de bugs (errores de código que hacen que no funciones) que se han detectado en el código analizado. En el caso de esta métrica se requiere que el valor no sea menor que `A` y el valor que ha arrojado el análisis del código es de `E` (19 bugs)
- `Security Rating`: este apartado hace referencia al número de vulnerabilidades (código que puede ser explotado por adversarios) que se han detectado. Esta métrica requiere un valor que no sea menor que `A`, y en este caso el valor obtenido es `E` (27 vulnerabilidades).

Efectivamente el número de vulnerabilidades afecta a dicho veredicto, ya que el hecho de que existan vulnerabilidades hacen que no se pueda obtener una puntuación de `A` (la cual se corresponde con 0 vulnerabilidades). Con los bugs pasa exactamente lo mismo, la puntuación de `A` se obtiene con 0 bugs.


## Preguntas Mitigación

### 1. Elige una vulnerabilidad de tipo Blocker o Critical, explica cual es la vulnerabilidad detectada, por qué ha sido detectada (y si realmente es una vulnerabilidad y no un falso positivo).

### 2. Propon una solucion e impleméntela en una nueva rama del repositorio. Explica los cambios que arreglan dicha vulnerabilidad.

### 3. Crea una Pull Request de la nueva rama a la rama principal. ¿Qué opina Sonar de los cambios realizados?


### 4. Junta (merge) la nueva rama con la rama principal. Una vez finalizado el analisis, ¿qué cambios se han producido en el proyecto? ¿Cuantas vulnerabilidades detecta ahora?
